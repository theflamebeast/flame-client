## ESP logic adapted from: https://github.com/dementiaenjoyer/Minescript-Projects/tree/main/ESP
from flameclient.esp.globals import *;

HEALTHBARS = None
try:
    import flameclient.esp.healthbars as HEALTHBARS;
except Exception as e:
    if SETTINGS.get("DEBUG_MODE", False):
        try:
            echo("[flameclient] ESP import healthbars failed: " + str(e))
        except:
            pass

def render(draw_context):
    draw = DRAWING.new;

    # Heartbeat: proves render() is being invoked.
    try:
        if SETTINGS.get("DEBUG_MODE", False):
            global _debug_render_calls
            try:
                _debug_render_calls = _debug_render_calls + 1
            except:
                _debug_render_calls = 1
            if _debug_render_calls % 300 == 0:
                echo("[flameclient] ESP render tick")
    except:
        pass;

    # Debug overlay: drawing may break across versions; HUD_RENDER tick logs are primary.
    # Keep this best-effort and non-fatal.
    try:
        if SETTINGS.get("DEBUG_MODE", False):
            DRAWING.text(draw_context, "ESP callback OK", 6, 6, COLORS["TEXT_COLOR"]);
    except:
        pass;

    # Debug: prove basic fill/rect drawing works even if projection is broken.
    try:
        if SETTINGS.get("DEBUG_MODE", False):
            DRAWING.filled_rect(draw_context, 8, 20, 28, 40, make_color(200, 255, 60, 60));
    except:
        pass;

    level = LEVEL;
    player = PLAYER;
    game_renderer = GAME_RENDERER;

    if level is None or player is None or game_renderer is None:
        return

    if not SETTINGS["ESP_ENABLED"]:
        return;

    # 1.21.11+: camera / eye-pos methods frequently change across mappings.
    # Prefer stable Vec3 position methods that don't take tickDelta.
    camera_position = None;
    try:
        camera_position = game_renderer.getMainCamera().getPosition();
    except:
        pass;
    if (camera_position is None):
        try:
            camera_position = player.getPos();
        except:
            try:
                camera_position = player.position();
            except:
                return;

    for entity in level.players():
        # Settings Checks
        if (entity == player) and (not SETTINGS["SHOW_SELF"]):
            continue;
        
        if (not entity.isAlive()) and (not SETTINGS["SHOW_DEAD"]):
            continue;

        if (entity.isSpectator()) and (not SETTINGS["SHOW_SPECTATORS"]):
            continue;

        if (entity.isInvisible()) and (not SETTINGS["SHOW_INVISIBLE"]):
            continue;

        try:
            position = entity.getPos();
        except:
            try:
                position = entity.position();
            except:
                continue;
        distance = camera_position.distanceTo(position);

        name = entity.getName().getString();

        if (distance > SETTINGS["MAX_DISTANCE"]) or (name == "empty"):
            continue;
        
        try:
            eye_height = entity.getEyeHeight();
        except:
            try:
                eye_height = entity.getStandingEyeHeight();
            except:
                eye_height = entity.getBbHeight() * 0.9;

        w2s = MATH.world_to_screen(game_renderer, vector3(position.x, position.y - (eye_height * 0.5), position.z));

        if (not w2s):
            continue;

        bb_width, bb_height = entity.getBbWidth(), entity.getBbHeight();
        size = MATH.get_screen_scale(camera_position, position, bb_width, bb_height, player);

        x, y = size.x, size.y;
        w2s_x, w2s_y = w2s.x, w2s.y;

        half_x, half_y = (x * 0.5), (y * 0.5);

        # Keep coordinates as plain Python ints (Java Float wrappers can break int() casts in helpers).
        left, right = int(w2s_x - half_x), int(w2s_x + half_x);
        top, bottom = int(w2s_y - half_y), int(w2s_y + half_y);

        # 1. Draw Box
        if SETTINGS["SHOW_BOX"]:
            draw("rect", draw_context, left, top, right, bottom, COLORS["BOX_COLOR"]);
    
        # 2. Draw Healthbar
        if HEALTHBARS is not None:
            HEALTHBARS.draw(draw_context, entity, left, top, right, bottom);

        # 3. Draw Name
        if SETTINGS["SHOW_NAME"]:
            min_dist = SETTINGS.get("MIN_DISTANCE_NAME", 0)
            if distance >= min_dist:
                scale = SETTINGS.get("TEXT_SCALE", 1.0)
                base = (left + (right - left) * 0.5);
                draw("outline_text", draw_context, safe_literal(name).withStyle(FLAGS), base - (FONT.width(name) * scale * 0.5), top - 10, COLORS["TEXT_COLOR"]);
        
        # 4. Draw Weapon
        if SETTINGS["SHOW_WEAPON"]:
            scale = SETTINGS.get("TEXT_SCALE", 1.0)
            weapon = entity.getMainHandItem().getItemName().getString();
            formatted = (weapon == "Air" and "None") or weapon;
            
            if formatted != "None":
                base = (left + (right - left) * 0.5);
                draw("outline_text", draw_context, safe_literal(formatted).withStyle(FLAGS), base - (FONT.width(formatted) * scale * 0.5), bottom + 2.1, COLORS["TEXT_COLOR"]);

try:
    EVENT_MANAGER.register("ESP", render);
    if SETTINGS.get("DEBUG_MODE", False):
        try:
            echo("[flameclient] ESP render registered")
        except:
            pass
except Exception as e:
    if SETTINGS.get("DEBUG_MODE", False):
        try:
            echo("[flameclient] ESP register failed: " + str(e))
        except:
            pass
